# Migration Guide: Calcium Tracker → My Nutrients (Multi-Nutrient)

## Overview

This migration process converts user data from the legacy **My Calcium Tracker** (single-nutrient) format to the new **My Nutrients** (multi-nutrient) format.

The migration is a **two-stage process**:
1. **ID Mapping** - Maps old sequential food IDs to new stable appIds
2. **Multi-Nutrient Transform** - Converts calcium-only data to multi-nutrient format

## Prerequisites - Required Files

Before starting the migration, ensure these files exist in the `migration/` folder:

### Input Files (Must Have)
1. **User's backup file** - Export from user's current app instance
   - Example: `calcium-tracker-backup-2025-12-18.json`
   - Location: Exported by user, copy to migration folder
   - Contains: Journal entries, custom foods, settings, favorites, hidden foods

2. **Production baseline database** - `prod-foodDatabaseData.js`
   - Location: `migration/prod-foodDatabaseData.js`
   - Purpose: Snapshot of database from user's current production deployment
   - Size: ~657KB
   - Used to map old IDs to food names before matching to new database

3. **Current database** - `../src/lib/data/foodDatabaseData.js`
   - Location: `src/lib/data/foodDatabaseData.js`
   - Purpose: New multi-nutrient database with stable appIds
   - Size: ~3.3MB
   - Generated by data pipeline with keep list and salt preference

### Migration Scripts (Already Present)
- `migrate-backup-enhanced.mjs` - Stage 1: ID mapping
- `migrate_to_nutrients.mjs` - Stage 2: Multi-nutrient transform
- `analyze-journal-ids.mjs` - Validation: Analyze ID consistency
- `cleanup-journal-ids.mjs` - Cleanup: Fix ID inconsistencies

### Optional Override Files
- `food-id-overrides.json` - Manual food ID mappings for edge cases
- `food-replacements-mapping.json` - Substitute foods for discontinued items

## Migration Workflow

### Quick Reference - Full Migration Pipeline

```
Step 0 (Optional): Pre-Migration Merge
  ↓ merge_backups.py (if combining multiple backups)

Step 1: ID Mapping
  ↓ migrate-backup-enhanced.mjs
  ↓ merged-output.json created

Step 1a: Validate ID Mapping
  ↓ analyze-journal-ids.mjs

Step 2: Multi-Nutrient Transform
  ↓ migrate_to_nutrients.mjs
  ↓ nutrients-restore-PRODUCTION.json created

Step 2a: Validate Transform
  ↓ analyze-journal-ids.mjs
  ↓ If issues found →

Step 2b: Cleanup (if needed)
  ↓ cleanup-journal-ids.mjs
  ↓ nutrients-restore-PRODUCTION-cleaned.json created

Step 2c: Re-validate
  ↓ analyze-journal-ids.mjs
  ↓ Should show all clean ✅

Step 3: User Import
  ↓ Import final file into app
  ✅ Done!
```

---

### Step 0: Pre-Migration Merge (Optional - When Needed)

**When to use this step:**
- You have multiple backup files with different date ranges that need to be combined
- One backup has missing/corrupted data that was restored from an earlier backup
- You need to merge historical data with current data before migration

**Skip this step if:**
- You have a single, complete backup file to migrate
- All your data is already in one file

**What it does:**
- Merges journal entries from both files (union of all dates)
- Deduplicates custom foods by name (newer version wins on conflicts)
- Uses latest file's settings, favorites, serving preferences
- Creates single complete backup ready for migration

**Script:** `migration/merge_backups.py`

**Command:**
```bash
cd migration

python3 merge_backups.py \
  calcium-tracker-backup-OLD-with-missing-data.json \
  calcium-tracker-backup-CURRENT.json \
  calcium-tracker-MERGED.json
```

**Arguments:**
- First argument: Base/older backup file (e.g., file with restored missing dates)
- Second argument: Latest backup file (has current preferences and favorites)
- Third argument: Output merged file path

**Example Use Case:**
```bash
# Your wife's app is missing Aug 16-19 data
# You have an old backup (11-10) that HAS those dates
# You have a current backup (11-19) that's missing those dates but has current data

python3 merge_backups.py \
  calcium-tracker-backup-2025-11-10-updated-with-missing-data.json \
  calcium-tracker-backup-2025-11-19.json \
  calcium-tracker-backup-2025-11-19-merged.json

# Result: merged file has ALL dates (including Aug 16-19) plus current preferences
# Now use this merged file for Step 1 (ID Mapping)
```

**Output:**
- Creates merged backup file combining data from both sources
- Shows detailed merge report (what was added, deduplicated, preserved)
- Displays date range coverage

**Validation:**
```bash
# Quick check of merged file
python3 -c "
import json
data = json.load(open('calcium-tracker-MERGED.json'))
dates = sorted(data['journalEntries'].keys())
print(f'Total days: {len(dates)}')
print(f'Date range: {dates[0]} to {dates[-1]}')
print(f'Custom foods: {len(data[\"customFoods\"])}')
print(f'Check for missing dates in range...')
"
```

**After merging, proceed with normal migration workflow starting at Step 1.**

---

### Step 1: ID Mapping (Assign Stable appIds)

**What it does:**
- Loads old backup with sequential IDs (1, 2, 3, ...)
- Matches old IDs → food names (using prod baseline)
- Matches food names → new stable appIds (using current database)
- Preserves serving preferences by matching measure indices
- Generates merged backup with new appIds

**Command:**
```bash
cd migration

node migrate-backup-enhanced.mjs \
  --old-backup [user-backup].json \
  --old-database prod-foodDatabaseData.js \
  --curated-data ../src/lib/data/foodDatabaseData.js \
  --output merged-output.json
```

**Arguments:**
- `--old-backup` - User's exported backup file
- `--old-database` - Production baseline (maps old IDs to names)
- `--curated-data` - Current database (maps names to new appIds)
- `--output` - Merged output file with new appIds

**Output Files Created:**
- `merged-output.json` - Backup with old IDs replaced by new appIds (~240KB)
- `merged-output-migration-report.json` - Match quality report

**Validation:**
- Check migration report for match quality
- Look for "EXACT" and "HIGH" confidence matches
- Note any "UNMATCHED" items (will be dropped or substituted)

---

### Step 1a: Validate ID Mapping (Analysis)

**What it does:**
- Analyzes journal entries for ID field consistency
- Reports custom foods with/without customFoodId
- Reports database foods with/without appId
- Identifies legacy positive IDs in customFoodId field
- Checks isCustom flag consistency

**Command:**
```bash
node analyze-journal-ids.mjs merged-output.json
```

**Optional verbose mode:**
```bash
node analyze-journal-ids.mjs merged-output.json --verbose
```

**What to look for:**
- Custom foods should have `customFoodId` (negative IDs like -1, -2, -3)
- Database foods should have `appId` (positive IDs from database)
- No entries should have BOTH `customFoodId` AND `appId`
- `isCustom` flag should match ID type
- No positive IDs in `customFoodId` field (legacy artifact)

**Expected results after Stage 1:**
- Most database foods will NOT have appId yet (added in Stage 2)
- Custom foods should have negative customFoodId values
- May see some legacy positive IDs that need cleanup

---

### Step 2: Multi-Nutrient Transform

**What it does:**
- Loads merged backup (with new appIds)
- Expands calcium-only values to multi-nutrient format
- Scales all nutrient values based on serving quantity
- Preserves all metadata (settings, preferences, favorites, hidden)
- Generates final restore file ready for import

**Command:**
```bash
node migrate_to_nutrients.mjs \
  --merged-backup merged-output.json \
  --new-database ../src/lib/data/foodDatabaseData.js \
  --output nutrients-restore-PRODUCTION.json
```

**Arguments:**
- `--merged-backup` - Output from Step 1
- `--new-database` - Current database (for nutrient lookups)
- `--output` - Final restore file for user

**Output Files Created:**
- `nutrients-restore-PRODUCTION.json` - Final migrated backup (~400-500KB)
- Migration summary in console output

**Validation:**
```bash
# Quick validation check
node -e "
  const fs = require('fs');
  const data = JSON.parse(fs.readFileSync('nutrients-restore-PRODUCTION.json'));
  console.log('Days:', Object.keys(data.journalEntries).length);
  console.log('Total Entries:', Object.values(data.journalEntries).flat().length);
  console.log('Custom Foods:', data.customFoods.length);
  console.log('Settings:', !!data.settings);
  console.log('Preferences:', !!data.preferences);
  console.log('Hidden Foods:', data.hiddenFoodIds ? data.hiddenFoodIds.length : 0);
"
```

**Expected output:**
- Days: ~145 (or user's actual day count)
- Total Entries: ~1,148 (or user's actual entry count)
- Custom Foods: ~66 (or user's actual custom food count)
- Settings: true
- Preferences: true
- Hidden Foods: 0-50 (varies by user)

---

### Step 2a: Validate Multi-Nutrient Transform (Analysis)

**What it does:**
- Re-analyzes journal entries after multi-nutrient transformation
- Verifies ID fields are correct after migration
- Identifies any remaining inconsistencies

**Command:**
```bash
node analyze-journal-ids.mjs nutrients-restore-PRODUCTION.json
```

**Optional verbose mode:**
```bash
node analyze-journal-ids.mjs nutrients-restore-PRODUCTION.json --verbose
```

**What to look for:**
- All custom foods should have `customFoodId` (negative IDs)
- Database foods should have `appId` (positive IDs) where possible
- No entries with BOTH `customFoodId` AND `appId`
- `isCustom` flag matches ID type
- No positive IDs in `customFoodId` field

**Expected results:**
- ✅ If clean: "All journal entries have consistent ID fields!"
- ⚠️ If issues found: Proceed to Step 2b (Cleanup)

---

### Step 2b: Cleanup ID Inconsistencies (If Needed)

**When to run this step:**
- Only if Step 2a analysis shows inconsistencies
- Skip if analysis shows all entries are clean

**What it does:**
- Backfills missing `customFoodId` for custom foods
- Backfills missing `appId` for database foods
- Moves legacy positive IDs from customFoodId to appId
- Ensures `isCustom` flag consistency
- Supports manual override file for name mismatches
- Creates detailed change log

**Command (dry-run first):**
```bash
node cleanup-journal-ids.mjs \
  --input nutrients-restore-PRODUCTION.json \
  --output nutrients-restore-PRODUCTION-cleaned.json \
  --database ../src/lib/data/foodDatabaseData.js \
  --dry-run
```

**Review the changes**, then run without dry-run:
```bash
node cleanup-journal-ids.mjs \
  --input nutrients-restore-PRODUCTION.json \
  --output nutrients-restore-PRODUCTION-cleaned.json \
  --database ../src/lib/data/foodDatabaseData.js
```

**Arguments:**
- `--input` - File to clean (nutrients-restore-PRODUCTION.json)
- `--output` - Cleaned output file
- `--database` - Current database (for backfilling appIds)
- `--custom-foods` - (Optional) Custom foods file (uses backup's customFoods if not provided)
- `--overrides` - (Optional) Manual override file for custom food ID assignments (see below)
- `--dry-run` - (Optional) Preview changes without writing output

**Output Files Created:**
- `nutrients-restore-PRODUCTION-cleaned.json` - Cleaned backup
- `nutrients-restore-PRODUCTION-cleaned-changelog.json` - Detailed change log

**What it fixes:**
1. **Custom foods missing customFoodId**: Backfills by matching name + calcium value
2. **Database foods missing appId**: Backfills by matching name to database
3. **Legacy positive IDs in customFoodId**: Moves to appId field (database foods)
4. **Inconsistent isCustom flag**: Sets to true if has customFoodId
5. **Both IDs present**: Removes incorrect ID based on isCustom flag

---

#### Handling Name Mismatches with Manual Overrides

**Why this is needed:**
The cleanup script uses exact name + calcium matching to backfill customFoodId. However, if users edited journal entry names after creation (which the legacy app allowed), the names may not match exactly.

**Example mismatch:**
- Custom food definition: `"Oikos Yogurt, plain , nonfat"` (ID -50)
- Journal entry name: `"Oikos Pro Plain Yogurt"` (same food, different name)
- Result: Cleanup script can't match → entry left without customFoodId

**Creating a manual override file:**

1. **Check the changelog** for warnings like:
   ```
   Warning: Could not backfill customFoodId for "Oikos Pro Plain Yogurt"
   ```

2. **Create `custom-food-overrides.json`** in the migration folder:
   ```json
   {
     "customFoodIdOverrides": {
       "2025-11-30[10]": {
         "entryName": "Oikos Pro Plain Yogurt",
         "assignedId": -50,
         "matchedTo": "Oikos Yogurt, plain , nonfat",
         "reason": "User edited journal entry name after creation - same food, different name variant",
         "calcium": 270,
         "serving": "0.75 cups"
       }
     }
   }
   ```

   **Override key format:** `"YYYY-MM-DD[index]"` where index is the entry position in that day's array
   - Example: `"2025-11-30[10]"` = 11th entry (0-indexed) on November 30, 2025

3. **Re-run cleanup with overrides:**
   ```bash
   node cleanup-journal-ids.mjs \
     --input nutrients-restore-PRODUCTION.json \
     --output nutrients-restore-PRODUCTION-cleaned.json \
     --database ../src/lib/data/foodDatabaseData.js \
     --overrides custom-food-overrides.json
   ```

4. **Verify in changelog:**
   The output should show:
   ```
   Applied manual override: customFoodId = -50 (matched to "Oikos Yogurt, plain , nonfat")
   ```

**Finding the correct ID to assign:**
- Look in the `customFoods` array in your backup file
- Match by calcium value, measure, and similar name
- Use the custom food's `id` field as the `assignedId` in your override

**Multiple overrides:**
You can specify multiple entries in the same override file:
```json
{
  "customFoodIdOverrides": {
    "2025-11-30[10]": { "assignedId": -50, ... },
    "2025-12-05[3]": { "assignedId": -23, ... },
    "2025-12-15[7]": { "assignedId": -50, ... }
  }
}
```

---

### Step 2c: Re-validate After Cleanup

**Command:**
```bash
node analyze-journal-ids.mjs nutrients-restore-PRODUCTION-cleaned.json
```

**Expected result:**
- ✅ "All journal entries have consistent ID fields!"
- No inconsistencies reported
- All custom foods have customFoodId or are documented as orphans
- Most database foods have appId (some may be legitimately missing if unmatched)

**If still showing issues:**
- Review the changelog to see what was changed
- Check for orphaned custom foods (no matching definition)
- Check for unmatched database foods (name changed in new database)
- Consider manual fixes in food-id-overrides.json

---

### Step 3: User Import

**Instructions for user:**
1. Open My Nutrients app (new multi-nutrient version)
2. Go to Settings → Import/Export
3. Click "Import Data"
4. Select `nutrients-restore-PRODUCTION.json`
5. Confirm import
6. Verify data loaded correctly

## Data Structure Changes

### Legacy Format (Calcium-Only)
```json
{
  "journalEntries": {
    "2025-01-15": [
      {
        "foodId": 1258,
        "quantity": 2,
        "calcium": 276
      }
    ]
  }
}
```

### New Format (Multi-Nutrient)
```json
{
  "journalEntries": {
    "2025-01-15": [
      {
        "id": "abc-123",
        "foodId": 13562,
        "quantity": 2,
        "nutrients": {
          "protein": 15.98,
          "calcium": 552,
          "fiber": 0,
          "vitaminD": 5.8
        }
      }
    ]
  }
}
```

**Key Changes:**
- Sequential IDs (1, 2, 3) → Stable appIds (10001, 13562, etc.)
- Single `calcium` field → `nutrients` object with 20+ nutrients
- Added `id` field (UUID) to each journal entry
- Preserved quantity, measure index, custom food flag

## Troubleshooting

### "Error: Missing required arguments" (merge_backups.py)
- Ensure all 3 arguments are provided: base-file, latest-file, output-file
- Check file paths are correct and files exist

### "Error: Missing required arguments" (migrate-backup-enhanced.mjs)
- Ensure all 4 arguments are provided to migrate-backup-enhanced.mjs
- Use named argument format (--old-backup, --old-database, etc.)

### "Error: Cannot find module"
- Run from migration folder: `cd migration`
- Verify Node.js is installed: `node --version` (need v14+)
- Verify Python 3 is installed: `python3 --version` (for merge script)

### Missing dates in migrated data
- Check if you need Step 0 (Pre-Migration Merge) to combine multiple backups
- Review source backup file(s) to confirm all expected dates are present
- Use merge_backups.py to combine files before running migration scripts

### High unmatched food count
- Check prod-foodDatabaseData.js exists and is correct baseline
- Review unmatched foods in migration report
- Add manual mappings to food-id-overrides.json if needed

### Nutrient values seem wrong
- Verify serving quantity preserved correctly
- Check migration report for measure index matching
- Compare sample entries between old and new backup

### Missing custom foods
- Custom foods should transfer automatically
- Check nutrients-restore-PRODUCTION.json has customFoods array
- Verify custom food IDs start with "custom-"

### ID validation issues
- Run analyze-journal-ids.mjs to identify specific problems
- Common issues:
  - **Custom foods without customFoodId**: Run cleanup script to backfill
  - **Database foods without appId**: Run cleanup script to backfill
  - **Legacy positive IDs in customFoodId**: Run cleanup script to move to appId
  - **Both IDs present**: Run cleanup script to remove incorrect ID
  - **isCustom flag mismatch**: Run cleanup script to fix flag
- Always run cleanup with --dry-run first to preview changes
- Review changelog after cleanup to verify changes are correct

### Food history showing wrong entries
- This was caused by `undefined === undefined` bug in getFoodHistory
- Fixed in NutrientService.ts:1061 (changed `food.appId` to `food.id`)
- Rebuild app and test again
- If still showing issues, ensure journal entries have correct appId values
- Run analyze-journal-ids.mjs to verify ID fields are populated

## Files Reference

### Keep These Files (Required)
- `prod-foodDatabaseData.js` - Production baseline (657KB)
- `merge_backups.py` - Pre-migration merge script (optional, for combining backups)
- `migrate-backup-enhanced.mjs` - Stage 1 script (ID mapping)
- `migrate_to_nutrients.mjs` - Stage 2 script (multi-nutrient transform)
- `analyze-journal-ids.mjs` - Validation script (analyze ID consistency)
- `cleanup-journal-ids.mjs` - Cleanup script (fix ID inconsistencies)
- `calcium-tracker-backup-2025-12-18.json` - Test backup (241KB)
- `food-id-overrides.json` - Manual mappings (7.5KB)
- Migration documentation files (*.md)

### Generated Files (Can Delete After Import)
- `merged-output.json` - Intermediate file from Stage 1
- `merged-output-migration-report.json` - Stage 1 report
- `nutrients-restore-PRODUCTION.json` - Final output from Stage 2
- `nutrients-restore-PRODUCTION-cleaned.json` - Final output after cleanup (if needed)
- `nutrients-restore-PRODUCTION-cleaned-changelog.json` - Cleanup change log (if cleanup was run)
- Use the cleaned version if cleanup was needed, otherwise use the Stage 2 output

### Test Files (Already Cleaned Up)
- Test migration outputs removed in commit f8a4f13
- Only production migration files remain

## Migration History

- **2025-11-10** - Initial migration tests
- **2025-11-19** - Enhanced measure matching, pre-migration merge for missing Aug dates
- **2025-12-18** - Final test run with all 8 fixes applied
- **2025-12-23** - Documentation updated, ready for production
- **2025-12-24** - Added Step 0 (Pre-Migration Merge) documentation, updated merge_backups.py with CLI args
- **2025-12-26** - Added appId field to journal entries for reliable food history
  - Created analyze-journal-ids.mjs for ID validation
  - Created cleanup-journal-ids.mjs for ID cleanup
  - Updated migration workflow with validation and cleanup steps
  - Enhanced getFoodHistory to use appId matching for database foods
  - Migration now ensures all entries have correct ID fields (customFoodId or appId)
- **2025-12-27** - Enhanced cleanup script and app code for data integrity
  - **Phase 1: Manual Override System**
    - Added `--overrides` flag to cleanup-journal-ids.mjs
    - Supports manual ID assignment for name mismatches
    - Prevents automatic fuzzy matching (user control for ambiguous cases)
    - Created custom-food-overrides.json format for manual mappings
  - **Phase 2: Prevent ID Reuse & Edit Restrictions**
    - Added logical deletion (isDeleted flag) to prevent custom food ID reuse
    - Modified deleteCustomFood to mark foods as deleted instead of removing
    - Filtered deleted foods from UI (search, database page) while preserving for ID tracking
    - Added readonly constraints to journal entry editing (name and nutrients immutable, only serving size editable)
    - Enforced data philosophy: Journal = historical record; Database = grounded truth

See `MIGRATION-CORRECTED-2025-12-18.md` for complete migration log with all fixes applied.

## Success Criteria

✅ All journal entries migrated (145 days, 1,148 entries expected)
✅ All custom foods preserved (66 expected)
✅ Settings and preferences intact
✅ Serving preferences maintained (measure index matching)
✅ Nutrient values scaled correctly by quantity
✅ Hidden foods and favorites transferred
✅ No errors in migration output
✅ **ID field validation:**
  - All custom food entries have `customFoodId` (negative IDs) or are documented as orphans
  - Database food entries have `appId` (positive IDs) where possible
  - No entries have BOTH `customFoodId` AND `appId`
  - `isCustom` flag matches ID field type
  - No legacy positive IDs in `customFoodId` field
✅ **Food history feature:**
  - Custom food history works reliably (uses customFoodId matching)
  - Database food history works reliably (uses appId matching, not name matching)
  - No duplicate/incorrect entries in food history
✅ User can import and use the app normally

---

**Last Updated:** December 27, 2025
**Migration Scripts Version:** Enhanced with appId support, ID validation, manual overrides, and logical deletion
**Ready for Production:** Yes (requires full migration pass with validation/cleanup)
